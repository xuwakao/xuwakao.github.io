<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print"/>

    <script src="/javascripts/jquery.js" type="text/javascript"></script>
    <script src="/javascripts/common.js" type="text/javascript"></script>

    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Fresco图片加载框架（二）————Producer</title>
</head>

<body>
<div class="bodyHeader">
    <h2>
        <a href="index.html">主页</a>
    </h2>
</div>
<div id="container">

    <div class="post">
        <h1 class="postTitle">
            <a id="cb_post_title_url" class="postTitle2" href="http://wacao.cn/fresco-producer.html">【Android】Fresco图片加载框架（二）————Producer</a>
        </h1>
        <div class="clear"></div>
        <div class="postBody">
            <div id="cnblogs_post_body"><div>
                <div>
                    <div class="linenums">
                        <div class="L0">
                            <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
* 本文可以随意转载到任何网站或者App，
* BUT
* 转载也要按“基本法”，
* 请注明原文出处和作者
</span><span style="color: #008000;">*/</span></pre>
                                <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                            <p>&nbsp;</p>
                        </div>
                    </div>
                </div>
                <div>&nbsp;</div>
            </div>
                <p><a href="https://github.com/facebook/fresco">官方源码地址</a></p>
                <div>&nbsp;</div>
                <div><a href="http://frescolib.org/index.html">fresco官方高大上介绍（1）</a>（注意：前方有堵墙）</div>
                <div><a href="https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/">fresco官方高大上介绍</a><a href="https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/">（2）</a>（注意：前方有堵墙）</div>
                <div>&nbsp;</div>
                <div><span style="color: #ff0000;"><strong>介绍：</strong></span></div>
                <div>上一篇大概介绍了fresco这个lib的整体结构和流程，这篇主要介绍<strong><em>fresco</em></strong>中关键的一部分--<strong><span style="text-decoration: underline;"><em>Producer</em></span></strong>。</div>
                <div>&nbsp;</div>
                <div>个人觉得，<strong><em><span style="text-decoration: underline;">Producer</span></em></strong>基本是整个<strong><em><span style="text-decoration: underline;">ImagePipeline&nbsp;</span></em></strong>module的核心，串联了整个图片读取的流程和各个细节（decode，resize等等）的处理，而且感觉整个设计上很有意思，读完感觉收益匪浅。</div>
                <div>&nbsp;</div>
                <div>&nbsp;</div>
                <div><strong><span style="color: #ff0000;">正文：</span></strong></div>
                <div style="text-align: center;"><span style="font-size: 18px;"><em><span style="text-decoration: underline;">（分析主要是代码，相当枯燥~~~sigh）</span></em></span></div>
                <div>&nbsp;</div>
                <div>以一次网络请求的例，进行分析，其他类型的请求，例如从cache中读取图片等，都差不多。</div>
                <div>&nbsp;</div>
                <div>当<strong><em><span style="text-decoration: underline;">SimpleDraweeView#setController</span></em></strong>后，图片拉取的流程就开始了（详细流程可以参看上一篇的流程图）。忽略掉大部分细节，流程会来到（<strong><em><span style="text-decoration: underline;">PipelineDraweeControllerBuilder.java</span></em></strong>）：</div>
                <div>&nbsp;</div>
                <div>
                    <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #000000;">  @Override
  </span><span style="color: #0000ff;">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt;<span style="color: #000000;"> getDataSourceForRequest(
          ImageRequest imageRequest,
          Object callerContext,
          </span><span style="color: #0000ff;">boolean</span><span style="color: #000000;"> bitmapCacheOnly) {
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (bitmapCacheOnly) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mImagePipeline.fetchImageFromBitmapCache(imageRequest, callerContext);
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mImagePipeline.<span style="color: #ff0000;">fetchDecodedImage</span>(imageRequest, callerContext);
    }
  }</span></pre>
                        <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                    <p>&nbsp;</p>
                </div>
                <div>&nbsp;</div>
                <div>这里就是开始图片拉取，转入到<strong><em><span style="text-decoration: underline;">ImagePipeline</span></em></strong>核心流程。这里就是调用的<strong><em><span style="text-decoration: underline;">ImagePipeline</span></em></strong>的<strong><em><span style="text-decoration: underline;">fetchDecodeImage</span></em></strong>方法，从名字看，意思就是“获取一张decode（解码）的图片”，其代码(<strong><em><span style="text-decoration: underline;">ImagePipeline.java</span></em></strong>)：</div>
                <div>&nbsp;</div>
                <div>
                    <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #008000;">/**</span><span style="color: #008000;">
   * Submits a request for execution and returns a DataSource representing the pending decoded
   * image(s).
   * &lt;p&gt;The returned DataSource must be closed once the client has finished with it.
   * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> imageRequest the request to submit
   * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> a DataSource representing the pending decoded image(s)
   </span><span style="color: #008000;">*/</span>
  <span style="color: #0000ff;">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt;<span style="color: #000000;"> fetchDecodedImage(
          ImageRequest imageRequest,
          Object callerContext) {
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
      Producer</span>&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =<span style="color: #000000;">
              mProducerSequenceFactory.<span style="color: #ff0000;">getDecodedImageProducerSequence</span>(imageRequest);
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"><span style="color: #ff0000;"> submitFetchRequest</span>(
              producerSequence,
              imageRequest,
              ImageRequest.RequestLevel.FULL_FETCH,
              callerContext);
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception exception) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> DataSources.immediateFailedDataSource(exception);
    }
  }</span></pre>
                        <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                    <p>&nbsp;</p>
                </div>
                <div>&nbsp;</div>
                <div>这里有两个主要的函数：<strong><em><span style="text-decoration: underline;">getDecodedImageProducerSequence</span></em></strong>和<strong><em><span style="text-decoration: underline;">submitFetchRequest</span></em></strong></div>
                <div>&nbsp;</div>
                <div><strong><em><span style="text-decoration: underline;">getDecodedImageProducerSequence</span></em></strong>的返回值就是一个<strong><em><span style="text-decoration: underline;">Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt;</span></em></strong>。该值作为参数，传到第二个函数<strong><em><span style="text-decoration: underline;">submitFetchRequest</span></em></strong>中，先看<strong><em><span style="text-decoration: underline;">submitFetchRequest</span></em></strong>：</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #0000ff;">private</span> &lt;T&gt; DataSource&lt;CloseableReference&lt;T&gt;&gt;<span style="color: #000000;"> submitFetchRequest(
          Producer</span>&lt;CloseableReference&lt;T&gt;&gt;<span style="color: #000000;"><span style="color: #ff0000;"> producerSequence</span>,
          ImageRequest imageRequest,
          ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
          Object callerContext) {
    </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
      ImageRequest.RequestLevel lowestPermittedRequestLevel </span>=<span style="color: #000000;">
              ImageRequest.RequestLevel.getMax(
                      imageRequest.getLowestPermittedRequestLevel(),
                      lowestPermittedRequestLevelOnSubmit);
      SettableProducerContext settableProducerContext </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> SettableProducerContext(
              imageRequest,
              generateUniqueFutureId(),
              mRequestListener,
              callerContext,
              lowestPermittedRequestLevel,
</span><span style="color: #008000;">/*</span><span style="color: #008000;"> isPrefetch </span><span style="color: #008000;">*/</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">,
              imageRequest.getProgressiveRenderingEnabled() </span>||
                      !<span style="color: #000000;">UriUtil.isNetworkUri(imageRequest.getSourceUri()),
              imageRequest.getPriority());
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> CloseableProducerToDataSourceAdapter.<span style="color: #ff0000;">create</span>(
              <span style="color: #ff0000;">producerSequence</span>,
              settableProducerContext,
              mRequestListener);
    } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (Exception exception) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> DataSources.immediateFailedDataSource(exception);
    }
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>然后上面的create函数，就会一直到（<em><span style="text-decoration: underline;"><strong>AbstractProducerToDataSourceAdapter.java</strong></span></em>）：</div>
                <div>&nbsp;</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #0000ff;">protected</span><span style="color: #000000;"> AbstractProducerToDataSourceAdapter(
          Producer</span>&lt;T&gt;<span style="color: #000000;"><span style="color: #ff0000;"> producer</span>,
          SettableProducerContext settableProducerContext,
          RequestListener requestListener) {
    mSettableProducerContext </span>=<span style="color: #000000;"> settableProducerContext;
    mRequestListener </span>=<span style="color: #000000;"> requestListener;
    mRequestListener.onRequestStart(
            settableProducerContext.getImageRequest(),
            mSettableProducerContext.getCallerContext(),
            mSettableProducerContext.getId(),
            mSettableProducerContext.isPrefetch());
    producer.<span style="color: #ff0000;">produceResults</span>(<span style="color: #ff0000;">createConsumer</span>(), settableProducerContext);
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>到最后，<em><span style="text-decoration: underline;"><strong>submitFetchRequest</strong></span></em>会调用到<em><span style="text-decoration: underline;"><strong>Producer#produceResults</strong></span></em>方法，而这个producer就是前面那个<em><span style="text-decoration: underline;"><strong>getDecodedImageProducerSequence</strong></span></em>方法产生的，所以回头看这个<span style="font-size: 16px;"><strong><em><span style="color: #ff0000;"><span style="text-decoration: underline;">最最关键的地方</span></span></em></strong></span>。</div>
                <div>&nbsp;</div>
                <div><em><span style="text-decoration: underline;"><strong>getDecodedImageProducerSequence</strong></span></em>是<strong><em><span style="text-decoration: underline;">ProducerSequenceFactory.java</span></em></strong>的方法：</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">&nbsp;</div>
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #008000;">/**</span><span style="color: #008000;">
   * Returns a sequence that can be used for a request for a decoded image.
   *
   * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> imageRequest the request that will be submitted
   * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the sequence that should be used to process the request
   </span><span style="color: #008000;">*/</span>
  <span style="color: #0000ff;">public</span> Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt;<span style="color: #000000;"> getDecodedImageProducerSequence(
          ImageRequest imageRequest) {
    Producer</span>&lt;CloseableReference&lt;CloseableImage&gt;&gt; pipelineSequence =<span style="color: #000000;"><span style="color: #ff0000;">
            getBasicDecodedImageSequence</span>(imageRequest);
    </span><span style="color: #0000ff;">if</span> (imageRequest.getPostprocessor() != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getPostprocessorSequence(pipelineSequence);
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> pipelineSequence;
    }
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                    <div>从注释看，方法的意思就是返回一个用于请求decoded图片的sequence，而事实上，应该是返回一个Producer才对啊，</div>
                    <div><span style="text-decoration: underline; font-size: 18px;"><strong><em><span style="color: #ff0000;"><span data-wiz-span="data-wiz-span">那为什么是强调是sequence Producer，而不是，仅仅就是一个Producer？</span></span></em></strong></span></div>
                    <div>&nbsp;</div>
                </div>
                <div>带着疑问继续看：<em><span style="color: #ff0000;"><span data-wiz-span="data-wiz-span"><br></span></span></em></div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">&nbsp;</div>


                        </div>


                    </div>
                    <div>&nbsp;
                        <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">private</span> Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt;<span style="color: #000000;"> getBasicDecodedImageSequence(
          ImageRequest imageRequest) {
    Preconditions.checkNotNull(imageRequest);

    Uri uri </span>=<span style="color: #000000;"> imageRequest.getSourceUri();
    Preconditions.checkNotNull(uri, </span>"Uri is null."<span style="color: #000000;">);
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (UriUtil.isNetworkUri(uri)) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"><span style="color: #ff0000;"> getNetworkFetchSequence</span>();
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (UriUtil.isLocalFileUri(uri)) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (MediaUtils.isVideo(MediaUtils.extractMime(uri.getPath()))) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getLocalVideoFileFetchSequence();
      } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getLocalImageFileFetchSequence();
      }
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (UriUtil.isLocalContentUri(uri)) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getLocalContentUriFetchSequence();
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (UriUtil.isLocalAssetUri(uri)) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getLocalAssetFetchSequence();
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (UriUtil.isLocalResourceUri(uri)) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getLocalResourceFetchSequence();
    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (UriUtil.isDataUri(uri)) {
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> getDataFetchSequence();
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      String uriString </span>=<span style="color: #000000;"> uri.toString();
      </span><span style="color: #0000ff;">if</span> (uriString.length() &gt; 30<span style="color: #000000;">) {
        uriString </span>= uriString.substring(0, 30) + "..."<span style="color: #000000;">;
      }
      </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> RuntimeException("Unsupported uri scheme! Uri is: " +<span style="color: #000000;"> uriString);
    }
  }</span></pre>
                            <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                        <p>&nbsp;</p>
                    </div>
                </div>
                <div>看代码可知道，就是根据<strong><em><span style="text-decoration: underline;">ImageRequest</span></em></strong>的<em>Uri</em>，选择一个sequence Producer，我们这里假设是网络请求图片，所以选择的是图中红色方法<strong><em><span style="text-decoration: underline;">getNetworkFetchSequence</span></em></strong>，<em><span style="text-decoration: underline;">它也是返回一个Producer</span></em><em><span style="text-decoration: underline;">（可粗略看）</span></em>：</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #008000;">/**</span><span style="color: #008000;">
   * swallow result if prefetch -&gt; bitmap cache get -&gt;
   * background thread hand-off -&gt; multiplex -&gt; bitmap cache -&gt; decode -&gt; multiplex -&gt;
   * encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.
   </span><span style="color: #008000;">*/</span>
  <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">synchronized</span> Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt;<span style="color: #000000;"> getNetworkFetchSequence() {
    </span><span style="color: #0000ff;">if</span> (mNetworkFetchSequence == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
      mNetworkFetchSequence </span>=<span style="color: #000000;"><span style="color: #ff0000;">
              newBitmapCacheGetToDecodeSequence</span>(<span style="color: #ff0000;">getCommonNetworkFetchToEncodedMemorySequence</span>());
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mNetworkFetchSequence;
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>先看红色代码，<em><span style="text-decoration: underline;"><strong>getCommonNetworkFetchToEncodedMemorySequence</strong></span></em>，<em><span style="text-decoration: underline;">它也是返回一个Producer</span></em><em><span style="text-decoration: underline;">（可粗略看）</span></em>：</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #008000;">/**</span><span style="color: #008000;">
   * multiplex -&gt; encoded cache -&gt; disk cache -&gt; (webp transcode) -&gt; network fetch.
   </span><span style="color: #008000;">*/</span>
  <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">synchronized</span> Producer&lt;EncodedImage&gt;<span style="color: #000000;"> getCommonNetworkFetchToEncodedMemorySequence() {
    </span><span style="color: #0000ff;">if</span> (mCommonNetworkFetchToEncodedMemorySequence == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
      Producer</span>&lt;EncodedImage&gt; inputProducer =<span style="color: #000000;"><span style="color: #ff0000;">
              newEncodedCacheMultiplexToTranscodeSequence</span>(
                      mProducerFactory.<span style="color: #ff0000;">newNetworkFetchProducer</span>(mNetworkFetcher));
      mCommonNetworkFetchToEncodedMemorySequence </span>=<span style="color: #000000;">
              ProducerFactory.<span style="color: #ff0000;">newAddImageTransformMetaDataProducer</span>(inputProducer);

      </span><span style="color: #0000ff;">if</span> (mResizeAndRotateEnabledForNetwork &amp;&amp; !<span style="color: #000000;">mDownsampleEnabled) {
        mCommonNetworkFetchToEncodedMemorySequence </span>=<span style="color: #000000;">
                mProducerFactory.<span style="color: #ff0000;">newResizeAndRotateProducer</span>(
                        mCommonNetworkFetchToEncodedMemorySequence);
      }
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mCommonNetworkFetchToEncodedMemorySequence;
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>再看，<em><span style="text-decoration: underline;"><strong>newEncodedCacheMultiplexToTranscodeSequence</strong></span></em>，<em><span style="text-decoration: underline;">它也是返回一个Producer</span></em><em><span style="text-decoration: underline;">（可粗略看）</span></em>：</div>
                <div>&nbsp;</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #008000;">/**</span><span style="color: #008000;">
   * encoded cache multiplex -&gt; encoded cache -&gt; (disk cache) -&gt; (webp transcode)
   * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> inputProducer producer providing the input to the transcode
   * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> encoded cache multiplex to webp transcode sequence
   </span><span style="color: #008000;">*/</span>
  <span style="color: #0000ff;">private</span> Producer&lt;EncodedImage&gt;<span style="color: #000000;"> newEncodedCacheMultiplexToTranscodeSequence(
          Producer</span>&lt;EncodedImage&gt;<span style="color: #000000;"> inputProducer) {
    </span><span style="color: #0000ff;">if</span> (Build.VERSION.SDK_INT &lt;<span style="color: #000000;"> Build.VERSION_CODES.JELLY_BEAN_MR2) {
      inputProducer </span>=<span style="color: #000000;"> mProducerFactory.newWebpTranscodeProducer(inputProducer);
    }
    inputProducer </span>=<span style="color: #000000;"> mProducerFactory.<span style="color: #ff0000;">newDiskCacheProducer</span>(inputProducer);
    EncodedMemoryCacheProducer encodedMemoryCacheProducer </span>=<span style="color: #000000;">
            mProducerFactory.<span style="color: #ff0000;">newEncodedMemoryCacheProducer</span>(inputProducer);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mProducerFactory.<span style="color: #ff0000;">newEncodedCacheKeyMultiplexProducer</span>(encodedMemoryCacheProducer);
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>选其中一个红色函数看，newDiskCacheProducer，<em><span style="text-decoration: underline;">它也是返回一个Producer（可粗略看）</span></em>：</div>
                <div>&nbsp;</div>
                <div>
                    <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #0000ff;">public</span><span style="color: #000000;"> DiskCacheProducer newDiskCacheProducer(
          Producer</span>&lt;EncodedImage&gt;<span style="color: #000000;"> inputProducer) {
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"><span style="color: #ff0000;"> DiskCacheProducer</span>(
            mDefaultBufferedDiskCache,
            mSmallImageBufferedDiskCache,
            mCacheKeyFactory,
            <span style="color: #ff0000;">inputProducer</span>);
  }</span></pre>
                        <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                    <p>&nbsp;</p>
                </div>
                <div>&nbsp;</div>
                <div style="text-align: center;"><span style="font-size: 16px;"><em>好了，到此为止（列出的函数足够多了，晕~~~）</em></span></div>
                <div>&nbsp;</div>
                <div>其实上面，一连串几个函数，如果有细心的留意，它们有一个特点，就是，<span style="font-size: 16px;"><strong><em><span style="color: #ff0000;">（</span></em></strong></span><span data-wiz-span="data-wiz-span"><span style="font-size: 16px;"><strong><em><span style="color: #ff0000;">每一个函数）都以 （上一个函数）产生的Producer作为参数进行传递</span></em></strong></span>。</span></div>
                <div>&nbsp;</div>
                <div>&nbsp;</div>
                <div>
                    <div>这样的设计，是不是有似曾相识的感觉，看下面的代码应该就能够了解得更深：</div>
                    <div>&nbsp;</div>
                    <div>
                        <div>
                            <div class="linenums">
                                <div class="L0">
                                    <div class="cnblogs_code">
<pre>FileInputStream fileInputStream = <span style="color: #0000ff;">new</span> FileInputStream("/test.txt"<span style="color: #000000;">);

InputStreamReader inputStreamReader </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> InputStreamReader(<span style="color: #ff0000;">fileInputStream</span>);

BufferedReader bufferedReader </span>= <span style="color: #0000ff;">new</span> BufferedReader(<span style="color: #ff0000;">inputSteamReader</span>);</pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div>&nbsp;</div>
                    </div>
                </div>
                <div>很熟悉了吧，可以把sequence Producer就看成是上面这样的一个逻辑~~~</div>
                <div>&nbsp;</div>
                <div>那么这样做的作用是什么？我们选一个简单Producer来分析，就以<em><span style="text-decoration: underline;"><strong>DiskCacheProducer</strong></span></em>为例：</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre> <span style="color: #0000ff;">public</span><span style="color: #000000;"> DiskCacheProducer(
          BufferedDiskCache defaultBufferedDiskCache,
          BufferedDiskCache smallImageBufferedDiskCache,
          CacheKeyFactory cacheKeyFactory,
          Producer</span>&lt;EncodedImage&gt;<span style="color: #000000;"> inputProducer) {
    mDefaultBufferedDiskCache </span>=<span style="color: #000000;"> defaultBufferedDiskCache;
    mSmallImageBufferedDiskCache </span>=<span style="color: #000000;"> smallImageBufferedDiskCache;
    mCacheKeyFactory </span>=<span style="color: #000000;"> cacheKeyFactory;
    mInputProducer </span>=<span style="color: #000000;"> inputProducer;
  }

  </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> produceResults(
          </span><span style="color: #0000ff;">final</span> Consumer&lt;EncodedImage&gt;<span style="color: #000000;"> consumer,
          </span><span style="color: #0000ff;">final</span><span style="color: #000000;"> ProducerContext producerContext) {
    ImageRequest imageRequest </span>=<span style="color: #000000;"> producerContext.getImageRequest();
</span><span style="color: #008000;">//</span><span style="color: #008000;">如果diskcache disabled的话，那么直接执行maybeStartInputProducer</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">imageRequest.isDiskCacheEnabled()) {
      <span style="color: #ff0000;">maybeStartInputProducer</span>(consumer, consumer, producerContext);
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">final</span> ProducerListener listener =<span style="color: #000000;"> producerContext.getListener();
    </span><span style="color: #0000ff;">final</span> String requestId =<span style="color: #000000;"> producerContext.getId();
    listener.onProducerStart(requestId, PRODUCER_NAME);

    </span><span style="color: #0000ff;">final</span> CacheKey cacheKey =<span style="color: #000000;"> mCacheKeyFactory.getEncodedCacheKey(imageRequest);
    </span><span style="color: #0000ff;">final</span> BufferedDiskCache cache =<span style="color: #000000;">
            imageRequest.getImageType() </span>==<span style="color: #000000;"> ImageRequest.ImageType.SMALL
                    </span>?<span style="color: #000000;"> mSmallImageBufferedDiskCache
                    : mDefaultBufferedDiskCache;
    Continuation</span>&lt;EncodedImage, Void&gt; continuation = <span style="color: #0000ff;">new</span> Continuation&lt;EncodedImage, Void&gt;<span style="color: #000000;">() {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">回调</span>
<span style="color: #000000;">      @Override
      </span><span style="color: #0000ff;">public</span> Void then(Task&lt;EncodedImage&gt;<span style="color: #000000;"> task)
              </span><span style="color: #0000ff;">throws</span><span style="color: #000000;"> Exception {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">根据task是canceled，fault等状态决定如何执行</span>
        <span style="color: #0000ff;">if</span> (task.isCancelled() ||<span style="color: #000000;">
                (task.isFaulted() </span>&amp;&amp; task.getError() <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> CancellationException)) {
          listener.onProducerFinishWithCancellation(requestId, PRODUCER_NAME, </span><span style="color: #0000ff;">null</span><span style="color: #000000;">);
          consumer.onCancellation();
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (task.isFaulted()) {
          listener.onProducerFinishWithFailure(requestId, PRODUCER_NAME, task.getError(), </span><span style="color: #0000ff;">null</span><span style="color: #000000;">);
          </span><span style="color: #008000;">//</span><span style="color: #008000;">出错了，就调用maybeStartInputProducer</span>
<span style="color: #000000;"><span style="color: #ff0000;">          maybeStartInputProducer</span>(
                  consumer,
                  </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> DiskCacheConsumer(consumer, cache, cacheKey),
                  producerContext);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
          EncodedImage cachedReference </span>=<span style="color: #000000;"> task.getResult();
          </span><span style="color: #0000ff;">if</span> (cachedReference != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            listener.onProducerFinishWithSuccess(
                    requestId,
                    PRODUCER_NAME,
                    getExtraMap(listener, requestId, </span><span style="color: #0000ff;">true</span><span style="color: #000000;">));
            consumer.onProgressUpdate(</span>1<span style="color: #000000;">);
            consumer.onNewResult(cachedReference, </span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
            cachedReference.close();
          } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">没有结果，就调用maybeStartInputProducer</span>
<span style="color: #000000;">            listener.onProducerFinishWithSuccess(
                    requestId,
                    PRODUCER_NAME,
                    getExtraMap(listener, requestId, </span><span style="color: #0000ff;">false</span><span style="color: #000000;">));
            <span style="color: #ff0000;">maybeStartInputProducer</span>(
                    consumer,
                    </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> DiskCacheConsumer(consumer, cache, cacheKey),
                    producerContext);
          }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
      }
    };

    AtomicBoolean isCancelled </span>= <span style="color: #0000ff;">new</span> AtomicBoolean(<span style="color: #0000ff;">false</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">final</span> Task&lt;EncodedImage&gt; diskCacheLookupTask =<span style="color: #000000;">
            cache.get(cacheKey, isCancelled);
</span><span style="color: #008000;">//</span><span style="color: #008000;">执行task，task其实就是从缓存中取结果，执行后，前面的continuation就会被回调</span>
<span style="color: #000000;">    diskCacheLookupTask.continueWith(continuation);
    subscribeTaskForRequestCancellation(isCancelled, producerContext);
  }

  </span><span style="color: #008000;">//</span><span style="color: #008000;">调用mInputProducer的produceResults </span>
  <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"><span style="color: #ff0000;"> maybeStartInputProducer</span>(
          Consumer</span>&lt;EncodedImage&gt;<span style="color: #000000;"> consumerOfDiskCacheProducer,
          Consumer</span>&lt;EncodedImage&gt;<span style="color: #000000;"> consumerOfInputProducer,
          ProducerContext producerContext) {
    </span><span style="color: #0000ff;">if</span> (producerContext.getLowestPermittedRequestLevel().getValue() &gt;=<span style="color: #000000;">
            ImageRequest.RequestLevel.DISK_CACHE.getValue()) {
      consumerOfDiskCacheProducer.onNewResult(</span><span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
      </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }

    mInputProducer.produceResults(consumerOfInputProducer, producerContext);
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>从前面知道，当开始拉取图片的时候，<span style="text-decoration: underline;">Producer</span><strong><em><span style="text-decoration: underline;">#produceResult</span></em></strong>开始执行，红色注释标出了关键的步骤，从这些步骤可以看出，其实<strong><em><span style="text-decoration: underline;">DiskCacheProducer</span></em></strong>实的拉取图片时，做的任务大概就是：<span data-wiz-span="data-wiz-span"><span style="font-size: 18px;"><strong><span style="color: #ff0000;"><em>先看Diskcache中是否有缓存的图片，如果有，就直接返回缓存，如果没有，就用</em><span style="text-decoration: underline;"><em>inputProducer</em></span><em>来处理</em></span></strong></span>。</span></div>
                <div>&nbsp;</div>
                <div>然后，<strong><em><span style="text-decoration: underline;">inputProducer</span></em></strong>处理完结果会怎样呢？它处理的结果会在<strong><em><span style="text-decoration: underline;">consumer</span></em></strong>中接收到，上面的例子代码对应的就是<strong><em><span style="text-decoration: underline;">DiskCacheConsumer：</span></em></strong></div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre>  <span style="color: #008000;">/**</span><span style="color: #008000;">
   * Consumer that consumes results from next producer in the sequence.
   *
   * &lt;p&gt;The consumer puts the last result received into disk cache, and passes all results (success
   * or failure) down to the next consumer.
   </span><span style="color: #008000;">*/</span>
  <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">class</span> DiskCacheConsumer <span style="color: #0000ff;">extends</span> DelegatingConsumer&lt;EncodedImage, EncodedImage&gt;<span style="color: #000000;"> {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> BufferedDiskCache mCache;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span><span style="color: #000000;"> CacheKey mCacheKey;

    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> DiskCacheConsumer(
            </span><span style="color: #0000ff;">final</span> Consumer&lt;EncodedImage&gt;<span style="color: #000000;"> consumer,
            </span><span style="color: #0000ff;">final</span><span style="color: #000000;"> BufferedDiskCache cache,
            </span><span style="color: #0000ff;">final</span><span style="color: #000000;"> CacheKey cacheKey) {
      </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(consumer);
      mCache </span>=<span style="color: #000000;"> cache;
      mCacheKey </span>=<span style="color: #000000;"> cacheKey;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">inputProducer的结果会从这里返回，即newResult</span>
<span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> onNewResultImpl(EncodedImage newResult, <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isLast) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;">返回的结果加入cache中</span>
      <span style="color: #0000ff;">if</span> (newResult != <span style="color: #0000ff;">null</span> &amp;&amp;<span style="color: #000000;"> isLast) {
        mCache.put(mCacheKey, newResult);
      }
      </span><span style="color: #008000;">//</span><span style="color: #008000;">回调上一层procducer传进来的consumer</span>
<span style="color: #000000;">      getConsumer().onNewResult(newResult, isLast);
    }
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>到这里，应该就大概明白这个sequence Producer的作用了，所谓sequence Producer，其实就是<span style="font-size: 18px;"><strong><span data-wiz-span="data-wiz-span"><span style="color: #ff0000;"><em>一层层的Producer不断的嵌套连接起来，完成同一个任务，而每一个Producer都相互独立，完成各自任务；同时，Producer间产生的结果，也会相互传递，互为表里</em></span></span></strong></span>。可以称其为“Producer链”，但是“Producer链”本身被抽象成一个Producer，那么对于上层来看，这样一个复杂的处理逻辑就被隐藏起来了，变得更加容易理解。</div>
                <div>&nbsp;</div>
                <div>sequence Producer功能极其强大，不同的Producer的组合，产生了很多不同的效果，对于代码的扩展性，可复用性和灵活性都有很大好处。</div>
                <div>&nbsp;</div>
                <div>例如，<strong><em><span style="text-decoration: underline;">MultiplexProducer</span></em></strong>：</div>
                <div>&nbsp;</div>
                <div>注释：</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">/**</span><span style="color: #008000;">
* Producer for combining multiple identical requests into a single request.
*
* &lt;p&gt;Requests using the same key will be combined into a single request. This request is only
* cancelled when all underlying requests are cancelled, and returns values to all underlying
* consumers. If the request has already return one or more results but has not finished, then
* any requests with the same key will have the most recent result returned to them immediately.
*
* </span><span style="color: #808080;">@param</span><span style="color: #008000;"> &lt;K&gt; type of the key
* </span><span style="color: #808080;">@param</span><span style="color: #008000;"> &lt;T&gt; type of the closeable reference result that is returned to this producer
</span><span style="color: #008000;">*/</span><span style="color: #000000;">
@ThreadSafe
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span> MultiplexProducer&lt;K, T <span style="color: #0000ff;">extends</span> Closeable&gt; <span style="color: #0000ff;">implements</span> Producer&lt;T&gt;
 </pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div>理解为，多路复用Producer（什么鬼东西？），其实就是将相同的任务合并为一个，例如相同url的重复请求，如何做到的，关键代码：</div>
                <div>&nbsp;</div>
                <div>
                    <div>
                        <div class="linenums">
                            <div class="L0">
                                <div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #000000;">  @Override
  </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> produceResults(Consumer&lt;T&gt;<span style="color: #000000;"> consumer, ProducerContext context) {
    K key </span>=<span style="color: #000000;"> getKey(context);
    Multiplexer multiplexer;
    </span><span style="color: #0000ff;">boolean</span><span style="color: #000000;"> createdNewMultiplexer;
</span><span style="color: #008000;">//</span><span style="color: #008000;"> We do want to limit scope of this lock to guard only accesses to mMultiplexers map.
</span><span style="color: #008000;">//</span><span style="color: #008000;"> However what we would like to do here is to atomically lookup mMultiplexers, add new
</span><span style="color: #008000;">//</span><span style="color: #008000;"> consumer to consumers set associated with the map's entry and call consumer's callback with
</span><span style="color: #008000;">//</span><span style="color: #008000;"> last intermediate result. We should not do all of those things under this lock.</span>
    <span style="color: #0000ff;">do</span><span style="color: #000000;"> {
      createdNewMultiplexer </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
      </span><span style="color: #0000ff;">synchronized</span> (<span style="color: #0000ff;">this</span><span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">根据key获得多路复用器，当缓存没有的时候，才create一个，不然直接忽略</span>
        multiplexer =<span style="color: #000000;"> getExistingMultiplexer(key);
        </span><span style="color: #0000ff;">if</span> (multiplexer == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
          multiplexer </span>=<span style="color: #000000;"> createAndPutNewMultiplexer(key);
          createdNewMultiplexer </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
      }
</span><span style="color: #008000;">//</span><span style="color: #008000;"> addNewConsumer may call consumer's onNewResult method immediately. For this reason
</span><span style="color: #008000;">//</span><span style="color: #008000;"> we release "this" lock. If multiplexer is removed from mMultiplexers in the meantime,
</span><span style="color: #008000;">//</span><span style="color: #008000;"> which is not very probable, then addNewConsumer will fail and we will be able to retry.</span>
    } <span style="color: #0000ff;">while</span> (!<span style="color: #000000;">multiplexer.addNewConsumer(consumer, context));
    </span><span style="color: #008000;">//</span><span style="color: #008000;">如果前面没有创建，也就是存在缓存的多路复用器，那么就不会调用startInputProducerIfHasAttachedConsumers，然后inputProducer就不起作用了，这样，就起到合并请求的作用</span>

    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (createdNewMultiplexer) {
      multiplexer.startInputProducerIfHasAttachedConsumers();
    }
  }</span></pre>
                                    <div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="/images/fresco-analysis/copycode.gif" alt="复制代码"></a></span></div></div>
                                <p>&nbsp;</p>
                            </div>
                        </div>
                    </div>
                    <div>&nbsp;</div>
                </div>
                <div>不同的功能Producer还有很多，例如对图片进行resize和rotate的<strong><span style="text-decoration: underline;"><em>ResizeAndRotateProducer，&nbsp;</em></span></strong>异步执行任务的<em><span style="text-decoration: underline;"><strong>ThreadHandoffProducer</strong></span></em>等等，如此灵活的实现，得益于sequence Factory这种设计。</div>
                <div>&nbsp;</div>
                <div><span style="color: #ff0000;"><strong>总结</strong></span></div>
                <div>&nbsp;</div>
                <div>ImagePipeline的核心Producer，通过sequence的形式，很好的串联了整个图片网络读取，缓存，bitmap处理等流程，通过优秀的设计，保证的代码<strong>高扩展性</strong>，<strong>高可复用性</strong>和<strong>高灵活性</strong>。</div>
                <div>&nbsp;</div>
                <div>这种设计刚好对应就是“<strong>pipeline</strong>”这个词的含义，就如现代的pipelined CPU一样，把对指令的处理，拆分成多个stage，同时输入输出相互依赖和协作，共同完成一个任务。</div>
                <div style="text-align: center;">&nbsp;</div>
                <div style="text-align: center;">~~~文卒~~~</div></div><div id="MySignature"></div>
        </div>
    </div>
</div>


</body>
</html>